-- File: dftm.vhd
-- Generated by MyHDL 0.11
-- Date: Mon May 23 18:13:45 2022


library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_011.all;

entity dftm is
    port (
        clk_i: in std_logic;
        host_intf_rst_i: in std_logic;
        host_intf_rd_i: in std_logic;
        host_intf_wr_i: in std_logic;
        host_intf_addr_i: in unsigned(23 downto 0);
        host_intf_data_i: in unsigned(15 downto 0);
        host_intf_data_o: out unsigned(15 downto 0);
        host_intf_done_o: out std_logic;
        host_intf_rdPending_o: in std_logic;
        host_intf_dftm_i: in std_logic;
        host_intf_sdram_rst_i: in std_logic;
        host_intf_sdram_rd_i: out std_logic;
        host_intf_sdram_wr_i: out std_logic;
        host_intf_sdram_addr_i: inout unsigned(23 downto 0);
        host_intf_sdram_data_i: out unsigned(15 downto 0);
        host_intf_sdram_data_o: inout unsigned(15 downto 0);
        host_intf_sdram_done_o: in std_logic;
        host_intf_sdram_rdPending_o: in std_logic;
        host_intf_sdram_dftm_i: in std_logic
    );
end entity dftm;


architecture MyHDL of dftm is


type t_enum_OPERATION_MODE_1 is (
	NORMAL,
	RECODING_UP,
	RECODING_DOWN
	);
type t_enum_RECODING_MODE_2 is (
	READ,
	WAIT_READ,
	WRITE,
	WAIT_WRITE,
	WAIT_WRITE_1,
	WAIT_WRITE_2
	);

signal current_operation_mode: t_enum_OPERATION_MODE_1;
signal current_recoding_mode: t_enum_RECODING_MODE_2;
signal in_read: std_logic;
signal iram_send: std_logic;
signal recode_address: unsigned(23 downto 0);
signal recode_count: unsigned(15 downto 0);
signal recode_data_o: unsigned(15 downto 0);
signal recode_from_ecc: unsigned(2 downto 0);
signal recode_original_data: unsigned(15 downto 0);
signal recode_position: unsigned(15 downto 0);
signal recode_to_ecc: unsigned(2 downto 0);
type t_array_ram is array(0 to 256-1) of unsigned(2 downto 0);
signal ram: t_array_ram;

function MYHDL2_get_position(
    addr: in unsigned;
    page_size: in natural
    ) return integer is
begin
    return to_integer(addr / page_size);
end function MYHDL2_get_position;

function MYHDL3_get_configuration(
    mem: in unsigned
    ) return integer is
begin
    return to_integer((mem and to_unsigned(1, 3)));
end function MYHDL3_get_configuration;

function MYHDL4_get_encode(
    mem: in unsigned
    ) return integer is
begin
    return to_integer(shift_right(mem, 1));
end function MYHDL4_get_encode;

function MYHDL5_check(
    data: in integer;
    type: in integer
    ) return std_logic is
    variable c: integer;
    variable x: integer;
    variable d: integer;
    variable p0: integer;
    variable p1: integer;
    variable p2: integer;
    variable p3: integer;
    variable p4: integer;
    variable check: integer;
begin
    if (type = 0) then
        return '1';
    end if;
    if (type = 1) then
        c := (data and 1);
        x := shift_right(data, 1);
        x := x xor shift_right(x, 8);
        x := x xor shift_right(x, 4);
        x := x xor shift_right(x, 2);
        x := x xor shift_right(x, 1);
        x := ((not x) and 1);
        return stdl(c = x);
    end if;
    if (type = 2) then
        d := shift_right(data, 5);
        p0 := ((((((((((d and 1) xor (shift_right(d, 1) and 1)) xor (shift_right(d, 3) and 1)) xor (shift_right(d, 4) and 1)) xor (shift_right(d, 6) and 1)) xor (shift_right(d, 8) and 1)) xor (shift_right(d, 10) and 1)) xor (shift_right(d, 11) and 1)) xor (shift_right(d, 13) and 1)) xor (shift_right(d, 15) and 1));
        p1 := (((((((((d and 1) xor (shift_right(d, 2) and 1)) xor (shift_right(d, 3) and 1)) xor (shift_right(d, 5) and 1)) xor (shift_right(d, 6) and 1)) xor (shift_right(d, 9) and 1)) xor (shift_right(d, 10) and 1)) xor (shift_right(d, 12) and 1)) xor (shift_right(d, 13) and 1));
        p2 := (((((((((shift_right(d, 1) and 1) xor (shift_right(d, 2) and 1)) xor (shift_right(d, 3) and 1)) xor (shift_right(d, 7) and 1)) xor (shift_right(d, 8) and 1)) xor (shift_right(d, 9) and 1)) xor (shift_right(d, 10) and 1)) xor (shift_right(d, 14) and 1)) xor (shift_right(d, 15) and 1));
        p3 := (((((((shift_right(d, 4) and 1) xor (shift_right(d, 5) and 1)) xor (shift_right(d, 6) and 1)) xor (shift_right(d, 7) and 1)) xor (shift_right(d, 8) and 1)) xor (shift_right(d, 9) and 1)) xor (shift_right(d, 10) and 1));
        p4 := (((((shift_right(d, 11) and 1) xor (shift_right(d, 12) and 1)) xor (shift_right(d, 13) and 1)) xor (shift_right(d, 14) and 1)) xor (shift_right(d, 15) and 1));
        check := (data and 31);
        return stdl(check = ((((shift_left(p4, 4) or shift_left(p3, 3)) or shift_left(p2, 2)) or shift_left(p1, 1)) or p0));
    end if;
    if (type = 3) then
        return '1';
    end if;
    return '0';
end function MYHDL5_check;

function MYHDL6_decode(
    data: in integer;
    type: in integer
    ) return integer is
    variable d: integer;
    variable p0: integer;
    variable p1: integer;
    variable p2: integer;
    variable p3: integer;
    variable p4: integer;
    variable pg: integer;
    variable pr: integer;
    variable p: integer;
    variable np: integer;
begin
    if (type = 0) then
        return data;
    end if;
    if (type = 1) then
        return shift_right(data, 1);
    end if;
    if (type = 2) then
        d := shift_right(data, 5);
        p0 := ((((((((((d and 1) xor (shift_right(d, 1) and 1)) xor (shift_right(d, 3) and 1)) xor (shift_right(d, 4) and 1)) xor (shift_right(d, 6) and 1)) xor (shift_right(d, 8) and 1)) xor (shift_right(d, 10) and 1)) xor (shift_right(d, 11) and 1)) xor (shift_right(d, 13) and 1)) xor (shift_right(d, 15) and 1));
        p1 := (((((((((d and 1) xor (shift_right(d, 2) and 1)) xor (shift_right(d, 3) and 1)) xor (shift_right(d, 5) and 1)) xor (shift_right(d, 6) and 1)) xor (shift_right(d, 9) and 1)) xor (shift_right(d, 10) and 1)) xor (shift_right(d, 12) and 1)) xor (shift_right(d, 13) and 1));
        p2 := (((((((((shift_right(d, 1) and 1) xor (shift_right(d, 2) and 1)) xor (shift_right(d, 3) and 1)) xor (shift_right(d, 7) and 1)) xor (shift_right(d, 8) and 1)) xor (shift_right(d, 9) and 1)) xor (shift_right(d, 10) and 1)) xor (shift_right(d, 14) and 1)) xor (shift_right(d, 15) and 1));
        p3 := (((((((shift_right(d, 4) and 1) xor (shift_right(d, 5) and 1)) xor (shift_right(d, 6) and 1)) xor (shift_right(d, 7) and 1)) xor (shift_right(d, 8) and 1)) xor (shift_right(d, 9) and 1)) xor (shift_right(d, 10) and 1));
        p4 := (((((shift_right(d, 11) and 1) xor (shift_right(d, 12) and 1)) xor (shift_right(d, 13) and 1)) xor (shift_right(d, 14) and 1)) xor (shift_right(d, 15) and 1));
        pg := ((((shift_left(p4, 4) or shift_left(p3, 3)) or shift_left(p2, 2)) or shift_left(p1, 1)) or p0);
        pr := (data and 31);
        p := (pg xor pr);
        if (p = 0) then
            return d;
        end if;
        np := 0;
        if ((p = 1) or (p = 2) or (p >= 17)) then
            np := (p - 1);
        end if;
        if (p = 4) then
            np := 2;
        end if;
        if (p = 8) then
            np := 3;
        end if;
        if (p = 16) then
            np := 4;
        end if;
        if (p = 3) then
            np := 5;
        end if;
        if ((p >= 5) and (p < 9) and (p /= 8)) then
            np := (p + 1);
        end if;
        if ((p >= 9) and (p <= 15)) then
            np := p;
        end if;
        return shift_right((data xor shift_left(1, np)), 5);
    end if;
    if (type = 3) then
        return data;
    end if;
    return data;
end function MYHDL6_decode;

function MYHDL7_get_next_encode(
    enc: in integer
    ) return integer is
    variable L: line;
    variable LAST_ENCODE: natural;
begin
    LAST_ENCODE := 3;
    if (enc >= 3) then
        write(L, string'("more:"));
        write(L, string'(" "));
        write(L, to_string(enc));
        writeline(output, L);
        return enc;
    else
        write(L, string'("enc+1:"));
        write(L, string'(" "));
        write(L, to_string(enc));
        writeline(output, L);
        return (enc + 1);
    end if;
end function MYHDL7_get_next_encode;

function MYHDL8_decode(
    data: in integer;
    type: in integer
    ) return integer is
    variable d: integer;
    variable p0: integer;
    variable p1: integer;
    variable p2: integer;
    variable p3: integer;
    variable p4: integer;
    variable pg: integer;
    variable pr: integer;
    variable p: integer;
    variable np: integer;
begin
    if (type = 0) then
        return data;
    end if;
    if (type = 1) then
        return shift_right(data, 1);
    end if;
    if (type = 2) then
        d := shift_right(data, 5);
        p0 := ((((((((((d and 1) xor (shift_right(d, 1) and 1)) xor (shift_right(d, 3) and 1)) xor (shift_right(d, 4) and 1)) xor (shift_right(d, 6) and 1)) xor (shift_right(d, 8) and 1)) xor (shift_right(d, 10) and 1)) xor (shift_right(d, 11) and 1)) xor (shift_right(d, 13) and 1)) xor (shift_right(d, 15) and 1));
        p1 := (((((((((d and 1) xor (shift_right(d, 2) and 1)) xor (shift_right(d, 3) and 1)) xor (shift_right(d, 5) and 1)) xor (shift_right(d, 6) and 1)) xor (shift_right(d, 9) and 1)) xor (shift_right(d, 10) and 1)) xor (shift_right(d, 12) and 1)) xor (shift_right(d, 13) and 1));
        p2 := (((((((((shift_right(d, 1) and 1) xor (shift_right(d, 2) and 1)) xor (shift_right(d, 3) and 1)) xor (shift_right(d, 7) and 1)) xor (shift_right(d, 8) and 1)) xor (shift_right(d, 9) and 1)) xor (shift_right(d, 10) and 1)) xor (shift_right(d, 14) and 1)) xor (shift_right(d, 15) and 1));
        p3 := (((((((shift_right(d, 4) and 1) xor (shift_right(d, 5) and 1)) xor (shift_right(d, 6) and 1)) xor (shift_right(d, 7) and 1)) xor (shift_right(d, 8) and 1)) xor (shift_right(d, 9) and 1)) xor (shift_right(d, 10) and 1));
        p4 := (((((shift_right(d, 11) and 1) xor (shift_right(d, 12) and 1)) xor (shift_right(d, 13) and 1)) xor (shift_right(d, 14) and 1)) xor (shift_right(d, 15) and 1));
        pg := ((((shift_left(p4, 4) or shift_left(p3, 3)) or shift_left(p2, 2)) or shift_left(p1, 1)) or p0);
        pr := (data and 31);
        p := (pg xor pr);
        if (p = 0) then
            return d;
        end if;
        np := 0;
        if ((p = 1) or (p = 2) or (p >= 17)) then
            np := (p - 1);
        end if;
        if (p = 4) then
            np := 2;
        end if;
        if (p = 8) then
            np := 3;
        end if;
        if (p = 16) then
            np := 4;
        end if;
        if (p = 3) then
            np := 5;
        end if;
        if ((p >= 5) and (p < 9) and (p /= 8)) then
            np := (p + 1);
        end if;
        if ((p >= 9) and (p <= 15)) then
            np := p;
        end if;
        return shift_right((data xor shift_left(1, np)), 5);
    end if;
    if (type = 3) then
        return data;
    end if;
    return data;
end function MYHDL8_decode;

function MYHDL9_decode(
    data: in integer;
    type: in unsigned
    ) return integer is
    variable d: integer;
    variable p0: integer;
    variable p1: integer;
    variable p2: integer;
    variable p3: integer;
    variable p4: integer;
    variable pg: integer;
    variable pr: integer;
    variable p: integer;
    variable np: integer;
begin
    if (type = 0) then
        return data;
    end if;
    if (type = 1) then
        return shift_right(data, 1);
    end if;
    if (type = 2) then
        d := shift_right(data, 5);
        p0 := ((((((((((d and 1) xor (shift_right(d, 1) and 1)) xor (shift_right(d, 3) and 1)) xor (shift_right(d, 4) and 1)) xor (shift_right(d, 6) and 1)) xor (shift_right(d, 8) and 1)) xor (shift_right(d, 10) and 1)) xor (shift_right(d, 11) and 1)) xor (shift_right(d, 13) and 1)) xor (shift_right(d, 15) and 1));
        p1 := (((((((((d and 1) xor (shift_right(d, 2) and 1)) xor (shift_right(d, 3) and 1)) xor (shift_right(d, 5) and 1)) xor (shift_right(d, 6) and 1)) xor (shift_right(d, 9) and 1)) xor (shift_right(d, 10) and 1)) xor (shift_right(d, 12) and 1)) xor (shift_right(d, 13) and 1));
        p2 := (((((((((shift_right(d, 1) and 1) xor (shift_right(d, 2) and 1)) xor (shift_right(d, 3) and 1)) xor (shift_right(d, 7) and 1)) xor (shift_right(d, 8) and 1)) xor (shift_right(d, 9) and 1)) xor (shift_right(d, 10) and 1)) xor (shift_right(d, 14) and 1)) xor (shift_right(d, 15) and 1));
        p3 := (((((((shift_right(d, 4) and 1) xor (shift_right(d, 5) and 1)) xor (shift_right(d, 6) and 1)) xor (shift_right(d, 7) and 1)) xor (shift_right(d, 8) and 1)) xor (shift_right(d, 9) and 1)) xor (shift_right(d, 10) and 1));
        p4 := (((((shift_right(d, 11) and 1) xor (shift_right(d, 12) and 1)) xor (shift_right(d, 13) and 1)) xor (shift_right(d, 14) and 1)) xor (shift_right(d, 15) and 1));
        pg := ((((shift_left(p4, 4) or shift_left(p3, 3)) or shift_left(p2, 2)) or shift_left(p1, 1)) or p0);
        pr := (data and 31);
        p := (pg xor pr);
        if (p = 0) then
            return d;
        end if;
        np := 0;
        if ((p = 1) or (p = 2) or (p >= 17)) then
            np := (p - 1);
        end if;
        if (p = 4) then
            np := 2;
        end if;
        if (p = 8) then
            np := 3;
        end if;
        if (p = 16) then
            np := 4;
        end if;
        if (p = 3) then
            np := 5;
        end if;
        if ((p >= 5) and (p < 9) and (p /= 8)) then
            np := (p + 1);
        end if;
        if ((p >= 9) and (p <= 15)) then
            np := p;
        end if;
        return shift_right((data xor shift_left(1, np)), 5);
    end if;
    if (type = 3) then
        return data;
    end if;
    return data;
end function MYHDL9_decode;

function MYHDL10_decode(
    data: in integer;
    type: in unsigned
    ) return integer is
    variable d: integer;
    variable p0: integer;
    variable p1: integer;
    variable p2: integer;
    variable p3: integer;
    variable p4: integer;
    variable pg: integer;
    variable pr: integer;
    variable p: integer;
    variable np: integer;
begin
    if (type = 0) then
        return data;
    end if;
    if (type = 1) then
        return shift_right(data, 1);
    end if;
    if (type = 2) then
        d := shift_right(data, 5);
        p0 := ((((((((((d and 1) xor (shift_right(d, 1) and 1)) xor (shift_right(d, 3) and 1)) xor (shift_right(d, 4) and 1)) xor (shift_right(d, 6) and 1)) xor (shift_right(d, 8) and 1)) xor (shift_right(d, 10) and 1)) xor (shift_right(d, 11) and 1)) xor (shift_right(d, 13) and 1)) xor (shift_right(d, 15) and 1));
        p1 := (((((((((d and 1) xor (shift_right(d, 2) and 1)) xor (shift_right(d, 3) and 1)) xor (shift_right(d, 5) and 1)) xor (shift_right(d, 6) and 1)) xor (shift_right(d, 9) and 1)) xor (shift_right(d, 10) and 1)) xor (shift_right(d, 12) and 1)) xor (shift_right(d, 13) and 1));
        p2 := (((((((((shift_right(d, 1) and 1) xor (shift_right(d, 2) and 1)) xor (shift_right(d, 3) and 1)) xor (shift_right(d, 7) and 1)) xor (shift_right(d, 8) and 1)) xor (shift_right(d, 9) and 1)) xor (shift_right(d, 10) and 1)) xor (shift_right(d, 14) and 1)) xor (shift_right(d, 15) and 1));
        p3 := (((((((shift_right(d, 4) and 1) xor (shift_right(d, 5) and 1)) xor (shift_right(d, 6) and 1)) xor (shift_right(d, 7) and 1)) xor (shift_right(d, 8) and 1)) xor (shift_right(d, 9) and 1)) xor (shift_right(d, 10) and 1));
        p4 := (((((shift_right(d, 11) and 1) xor (shift_right(d, 12) and 1)) xor (shift_right(d, 13) and 1)) xor (shift_right(d, 14) and 1)) xor (shift_right(d, 15) and 1));
        pg := ((((shift_left(p4, 4) or shift_left(p3, 3)) or shift_left(p2, 2)) or shift_left(p1, 1)) or p0);
        pr := (data and 31);
        p := (pg xor pr);
        if (p = 0) then
            return d;
        end if;
        np := 0;
        if ((p = 1) or (p = 2) or (p >= 17)) then
            np := (p - 1);
        end if;
        if (p = 4) then
            np := 2;
        end if;
        if (p = 8) then
            np := 3;
        end if;
        if (p = 16) then
            np := 4;
        end if;
        if (p = 3) then
            np := 5;
        end if;
        if ((p >= 5) and (p < 9) and (p /= 8)) then
            np := (p + 1);
        end if;
        if ((p >= 9) and (p <= 15)) then
            np := p;
        end if;
        return shift_right((data xor shift_left(1, np)), 5);
    end if;
    if (type = 3) then
        return data;
    end if;
    return data;
end function MYHDL10_decode;

function MYHDL11_encode(
    data: in integer;
    type: in unsigned
    ) return integer is
    variable x: integer;
    variable d: integer;
    variable p0: integer;
    variable p1: integer;
    variable p2: integer;
    variable p3: integer;
    variable p4: integer;
begin
    if (type = 0) then
        return data;
    end if;
    if (type = 1) then
        x := data;
        x := x xor shift_right(x, 8);
        x := x xor shift_right(x, 4);
        x := x xor shift_right(x, 2);
        x := x xor shift_right(x, 1);
        x := ((not x) and 1);
        return (shift_left(data, 1) + x);
    end if;
    if (type = 2) then
        d := data;
        p0 := ((((((((((d and 1) xor (shift_right(d, 1) and 1)) xor (shift_right(d, 3) and 1)) xor (shift_right(d, 4) and 1)) xor (shift_right(d, 6) and 1)) xor (shift_right(d, 8) and 1)) xor (shift_right(d, 10) and 1)) xor (shift_right(d, 11) and 1)) xor (shift_right(d, 13) and 1)) xor (shift_right(d, 15) and 1));
        p1 := (((((((((d and 1) xor (shift_right(d, 2) and 1)) xor (shift_right(d, 3) and 1)) xor (shift_right(d, 5) and 1)) xor (shift_right(d, 6) and 1)) xor (shift_right(d, 9) and 1)) xor (shift_right(d, 10) and 1)) xor (shift_right(d, 12) and 1)) xor (shift_right(d, 13) and 1));
        p2 := (((((((((shift_right(d, 1) and 1) xor (shift_right(d, 2) and 1)) xor (shift_right(d, 3) and 1)) xor (shift_right(d, 7) and 1)) xor (shift_right(d, 8) and 1)) xor (shift_right(d, 9) and 1)) xor (shift_right(d, 10) and 1)) xor (shift_right(d, 14) and 1)) xor (shift_right(d, 15) and 1));
        p3 := (((((((shift_right(d, 4) and 1) xor (shift_right(d, 5) and 1)) xor (shift_right(d, 6) and 1)) xor (shift_right(d, 7) and 1)) xor (shift_right(d, 8) and 1)) xor (shift_right(d, 9) and 1)) xor (shift_right(d, 10) and 1));
        p4 := (((((shift_right(d, 11) and 1) xor (shift_right(d, 12) and 1)) xor (shift_right(d, 13) and 1)) xor (shift_right(d, 14) and 1)) xor (shift_right(d, 15) and 1));
        return (((((shift_left(d, 5) or shift_left(p4, 4)) or shift_left(p3, 3)) or shift_left(p2, 2)) or shift_left(p1, 1)) or p0);
    end if;
    if (type = 3) then
        return data;
    end if;
    return data;
end function MYHDL11_encode;

procedure MYHDL12_set_encode(
    signal mem: out unsigned;
    signal enc: in unsigned) is
begin
    mem(1) <= (enc and to_unsigned(1, 3))(0);
    mem(2) <= shift_right((enc and to_unsigned(2, 3)), 1)(0);
end procedure MYHDL12_set_encode;

begin




DFTM_MAIN: process (clk_i) is
    variable L: line;
    variable iram_current_position: integer;
    variable current_encode: integer;
    variable is_dynamic: integer;
    variable ram_inf: unsigned(2 downto 0);
    variable decode_ok: std_logic;
    variable next_encode: integer;
    variable recode: std_logic;
    variable recoding_current_address: integer;
    variable r_count: integer;
begin
    if rising_edge(clk_i) then
        if (current_operation_mode = NORMAL) then
            if bool(host_intf_dftm_i) then
                if bool(iram_send) then
                    host_intf_done_o <= '1';
                    iram_send <= '0';
                else
                    if bool(host_intf_rd_i) then
                        host_intf_data_o <= resize(ram(to_integer(host_intf_addr_i)), 16);
                        host_intf_done_o <= '0';
                        iram_send <= '1';
                    end if;
                    if bool(host_intf_wr_i) then
                        ram(to_integer(host_intf_addr_i)) <= to_unsigned(to_integer(host_intf_data_i), 3);
                        write(L, string'("WR"));
                        write(L, string'(" "));
                        write(L, to_hstring(host_intf_addr_i));
                        write(L, string'(" "));
                        write(L, string'("-"));
                        write(L, string'(" "));
                        write(L, to_hstring(host_intf_data_i));
                        writeline(output, L);
                        host_intf_done_o <= '0';
                        iram_send <= '1';
                    end if;
                end if;
            else
                iram_current_position := MYHDL2_get_position(host_intf_addr_i, 256);
                current_encode := 0;
                is_dynamic := 0;
                -- Accessing a area major than managed, we will read without encode
                if (iram_current_position < 256) then
                    ram_inf := ram(iram_current_position);
                    is_dynamic := MYHDL3_get_configuration(ram_inf);
                    is_dynamic := 1;
                    current_encode := MYHDL4_get_encode(ram_inf);
                end if;
                host_intf_sdram_addr_i <= host_intf_addr_i;
                host_intf_sdram_rd_i <= host_intf_rd_i;
                host_intf_sdram_wr_i <= host_intf_wr_i;
                host_intf_sdram_data_i <= host_intf_data_i;
                if (host_intf_sdram_rdPending_o = '1') then
                    in_read <= '1';
                end if;
                if bool(host_intf_sdram_done_o) then
                    if (in_read = '0') then
                        host_intf_done_o <= host_intf_sdram_done_o;
                    else
                        in_read <= '0';
                        decode_ok := MYHDL5_check(to_integer(host_intf_sdram_done_o), current_encode);
                        if (host_intf_addr_i = 120) then
                            decode_ok := '0';
                        end if;
                        if bool(decode_ok) then
                            host_intf_data_o <= to_unsigned(MYHDL6_decode(to_integer(host_intf_sdram_data_o), current_encode), 16);
                            host_intf_done_o <= host_intf_sdram_done_o;
                        else
                            next_encode := MYHDL7_get_next_encode(current_encode);
                            recode := stdl((next_encode /= current_encode) and (is_dynamic = 1));
                            write(L, string'("will recode:"));
                            write(L, string'(" "));
                            write(L, to_string(bool(recode)));
                            writeline(output, L);
                            write(L, string'("Code?:"));
                            write(L, string'(" "));
                            write(L, to_string((next_encode /= current_encode)));
                            writeline(output, L);
                            write(L, string'("Dyn?:"));
                            write(L, string'(" "));
                            write(L, to_string(is_dynamic));
                            writeline(output, L);
                            if bool(recode) then
                                current_operation_mode <= RECODING_UP;
                                current_recoding_mode <= READ;
                                recode_position <= to_unsigned(iram_current_position, 16);
                                recode_address <= host_intf_addr_i;
                                recode_from_ecc <= to_unsigned(current_encode, 3);
                                recode_to_ecc <= to_unsigned(next_encode, 3);
                                recode_count <= to_unsigned(0, 16);
                                host_intf_done_o <= '0';
                                host_intf_sdram_rd_i <= '0';
                            else
                                host_intf_data_o <= to_unsigned(MYHDL8_decode(to_integer(host_intf_sdram_data_o), current_encode), 16);
                                host_intf_done_o <= host_intf_sdram_done_o;
                                in_read <= '0';
                            end if;
                        end if;
                    end if;
                else
                    host_intf_done_o <= host_intf_sdram_done_o;
                end if;
            end if;
        else
            if ((recode_count = 0) and (current_recoding_mode = READ)) then
                write(L, string'("STARTING RECODING pos:"));
                write(L, string'(" "));
                write(L, to_hstring(recode_position));
                write(L, string'(" "));
                write(L, string'(", FROM ECC "));
                write(L, string'(" "));
                write(L, to_hstring(recode_from_ecc));
                write(L, string'(" "));
                write(L, string'(", to:"));
                write(L, string'(" "));
                write(L, to_hstring(recode_to_ecc));
                writeline(output, L);
            end if;
            recoding_current_address := to_integer((recode_position * 256) + recode_count);
            write(L, string'("RECODING "));
            write(L, string'(" "));
            write(L, to_hstring(recode_position));
            write(L, string'(" "));
            write(L, string'(" - "));
            write(L, string'(" "));
            write(L, to_hstring(recode_count));
            write(L, string'(" "));
            write(L, string'(" - "));
            write(L, string'(" "));
            write(L, to_string(recoding_current_address));
            writeline(output, L);
            if (current_recoding_mode = READ) then
                write(L, to_string(current_recoding_mode));
                write(L, string'(" "));
                write(L, to_string(recoding_current_address));
                writeline(output, L);
                host_intf_sdram_addr_i <= to_unsigned(recoding_current_address, 24);
                host_intf_sdram_rd_i <= '1';
                current_recoding_mode <= WAIT_READ;
            end if;
            if (current_recoding_mode = WAIT_READ) then
                host_intf_sdram_rd_i <= '0';
                write(L, to_string(current_recoding_mode));
                writeline(output, L);
                if bool(host_intf_sdram_done_o) then
                    current_recoding_mode <= WRITE;
                    recode_data_o <= to_unsigned(MYHDL9_decode(to_integer(host_intf_sdram_data_o), recode_from_ecc), 16);
                    recode_data_o <= to_unsigned(MYHDL10_decode(to_integer(host_intf_sdram_data_o), recode_from_ecc) + 1, 16);
                    if (recode_address = host_intf_sdram_addr_i) then
                        recode_original_data <= host_intf_sdram_data_o;
                    end if;
                    -- TODO IGNORING THE DECODE ERROR - Having not todo here ... 
                    write(L, string'("RECODING READ "));
                    write(L, string'(" "));
                    write(L, to_hstring(host_intf_sdram_data_o));
                    writeline(output, L);
                end if;
            end if;
            if (current_recoding_mode = WRITE) then
                write(L, to_string(current_recoding_mode));
                writeline(output, L);
                host_intf_sdram_addr_i <= to_unsigned(recoding_current_address, 24);
                host_intf_sdram_data_i <= to_unsigned(MYHDL11_encode(to_integer(recode_data_o), recode_to_ecc), 16);
                write(L, string'("RECODING WRITE "));
                write(L, string'(" "));
                write(L, to_hstring(host_intf_sdram_data_o));
                writeline(output, L);
                current_recoding_mode <= WAIT_WRITE;
            end if;
            if (current_recoding_mode = WAIT_WRITE) then
                write(L, to_string(current_recoding_mode));
                writeline(output, L);
                host_intf_sdram_wr_i <= '1';
                if bool(host_intf_sdram_done_o) then
                    host_intf_sdram_rd_i <= '0';
                    host_intf_sdram_wr_i <= '0';
                    r_count := to_integer(recode_count + 1);
                    if (r_count < 256) then
                        current_recoding_mode <= WAIT_WRITE_1;
                        recode_count <= to_unsigned(r_count, 16);
                    else
                        -- RECODING DONE
                        host_intf_data_o <= recode_original_data;
                        host_intf_sdram_data_o <= recode_original_data;
                        host_intf_done_o <= '1';
                        current_operation_mode <= NORMAL;
                        ram_inf := ram(to_integer(recode_position));
                        MYHDL12_set_encode(ram_inf, recode_to_ecc);
                        write(L, string'("Change encode pos:"));
                        write(L, string'(" "));
                        write(L, to_hstring(recode_position));
                        write(L, string'(" "));
                        write(L, string'(", from:"));
                        write(L, string'(" "));
                        write(L, to_hstring(recode_from_ecc));
                        write(L, string'(" "));
                        write(L, string'(",to:"));
                        write(L, string'(" "));
                        write(L, to_hstring(recode_to_ecc));
                        writeline(output, L);
                    end if;
                end if;
            end if;
            -- Need wait 2 cycle to wait the WRITE really happen
            if (current_recoding_mode = WAIT_WRITE_1) then
                current_recoding_mode <= WAIT_WRITE_2;
            end if;
            if (current_recoding_mode = WAIT_WRITE_2) then
                current_recoding_mode <= READ;
            end if;
        end if;
    end if;
end process DFTM_MAIN;

end architecture MyHDL;
