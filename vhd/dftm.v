// File: dftm.v
// Generated by MyHDL 0.11
// Date: Wed May 18 11:29:45 2022


`timescale 1ns/10ps

module dftm (
    clk_i,
    host_intf_rst_i,
    host_intf_rd_i,
    host_intf_wr_i,
    host_intf_addr_i,
    host_intf_data_i,
    host_intf_data_o,
    host_intf_done_o,
    host_intf_rdPending_o,
    host_intf_sdram_rst_i,
    host_intf_sdram_rd_i,
    host_intf_sdram_wr_i,
    host_intf_sdram_addr_i,
    host_intf_sdram_data_i,
    host_intf_sdram_data_o,
    host_intf_sdram_done_o,
    host_intf_sdram_rdPending_o
);


input clk_i;
input host_intf_rst_i;
input host_intf_rd_i;
input host_intf_wr_i;
input [23:0] host_intf_addr_i;
input [15:0] host_intf_data_i;
output [15:0] host_intf_data_o;
reg [15:0] host_intf_data_o;
output host_intf_done_o;
reg host_intf_done_o;
input host_intf_rdPending_o;
input host_intf_sdram_rst_i;
output host_intf_sdram_rd_i;
reg host_intf_sdram_rd_i;
output host_intf_sdram_wr_i;
reg host_intf_sdram_wr_i;
output [23:0] host_intf_sdram_addr_i;
reg [23:0] host_intf_sdram_addr_i;
output [15:0] host_intf_sdram_data_i;
reg [15:0] host_intf_sdram_data_i;
input [15:0] host_intf_sdram_data_o;
input host_intf_sdram_done_o;
input host_intf_sdram_rdPending_o;

reg [1:0] current_operation_mode;
reg [2:0] current_recoding_mode;
reg [15:0] recode_count;
reg [15:0] recode_data_o;
reg [2:0] recode_from_ecc;
reg [23:0] recode_position;
reg [2:0] recode_to_ecc;
wire [2:0] ram [0:128-1];


function integer MYHDL23_get_position;
    input [24-1:0] addr;
    input page_size;
    integer page_size;
begin: MYHDL33_RETURN
    MYHDL23_get_position = (addr / page_size);
end
endfunction

function integer MYHDL24_get_encode;
    input [3-1:0] mem;
begin: MYHDL34_RETURN
    MYHDL24_get_encode = (mem >>> 1);

end
endfunction

function MYHDL25_decoder_check;
    input [16-1:0] data;
    input type;
    integer type;
begin: MYHDL35_RETURN
    MYHDL25_decoder_check = 1'b1;
    
end
endfunction

function integer MYHDL26_get_next_encode;
    input enc;
    integer enc;
    integer LAST_ENCODE;
begin: MYHDL36_RETURN
    LAST_ENCODE = 3;
    if ((enc >= 3)) begin
        $write("more:");
        $write(" ");
        $write("%0d", enc);
        $write("\n");
        MYHDL26_get_next_encode = enc;    
    end
    else begin
        $write("enc+1:");
        $write(" ");
        $write("%0d", enc);
        $write("\n");
        MYHDL26_get_next_encode = (enc + 1);
    end
end
endfunction

function [1-1:0] MYHDL27_decoder;
    input [1-1:0] data;
    input type;
    integer type;
begin: MYHDL37_RETURN
    MYHDL27_decoder = data;
end
endfunction

function [1-1:0] MYHDL28_decoder;
    input [1-1:0] data;
    input type;
    integer type;
begin: MYHDL38_RETURN
    MYHDL28_decoder = data;
end
endfunction

function [1-1:0] MYHDL29_decoder;
    input [1-1:0] data;
    input type;
    integer type;
begin: MYHDL39_RETURN
    MYHDL29_decoder = data;
end
endfunction

function [16-1:0] MYHDL30_decoder;
    input [16-1:0] data;
    input [3-1:0] type;
begin: MYHDL40_RETURN
    MYHDL30_decoder = data;
end
endfunction

function [16-1:0] MYHDL31_encoder;
    input [16-1:0] data;
    input [3-1:0] type;
begin: MYHDL41_RETURN
    MYHDL31_encoder = data;
    
end
endfunction

task MYHDL32_set_encode;
    output [3-1:0] mem;
    input [3-1:0] enc;
begin: MYHDL42_RETURN
    mem[1] <= (enc & 1);
    mem[2] <= ((enc & 2) >>> 1);
end
endtask


always @(posedge clk_i) begin: DFTM_MAIN
    integer iram_current_position;
    integer current_encode;
    reg [3-1:0] ram_inf;
    reg decode_ok;
    integer next_encode;
    reg recode;
    integer recoding_current_address;
    integer r_count;
    if ((current_operation_mode == 2'b00)) begin
        iram_current_position = MYHDL23_get_position(host_intf_addr_i, 1);
        current_encode = 0;
        // Accessing a area major than managed, we will read without encode
        if ((iram_current_position > 1)) begin
            ram_inf = ram[(iram_current_position - 1)];
            current_encode = MYHDL24_get_encode(ram_inf);
        end
        host_intf_sdram_addr_i <= host_intf_addr_i;
        host_intf_sdram_rd_i <= host_intf_rd_i;
        host_intf_sdram_wr_i <= host_intf_wr_i;
        if (host_intf_sdram_done_o) begin
            host_intf_data_o <= host_intf_sdram_data_o;
            decode_ok = MYHDL25_decoder_check(host_intf_data_i, current_encode);
            // TODO Test Propose only - BITFLIP WHEN 120 
            decode_ok = (!(host_intf_rd_i && (host_intf_addr_i == 120)));
            $write("[DFTM] addr:");
            $write(" ");
            $write("%h", host_intf_data_i);
            $write(" ");
            $write(", ecc:");
            $write(" ");
            $write("%0d", current_encode);
            $write("\n");
            if ((decode_ok == 0)) begin
                next_encode = MYHDL26_get_next_encode(current_encode);
                recode = (next_encode != current_encode);
                $write("will recode:");
                $write(" ");
                if (recode)
                    $write("True");
                else
                    $write("False");
                $write("\n");
                if (recode) begin
                    current_operation_mode <= 2'b01;
                    current_recoding_mode <= 3'b000;
                    recode_position <= iram_current_position;
                    recode_from_ecc <= current_encode;
                    recode_to_ecc <= next_encode;
                    recode_count <= 0;
                    host_intf_done_o <= 1'b0;
                    host_intf_sdram_rd_i <= 1'b0;
                    host_intf_sdram_wr_i <= 1'b0;
                end
                else begin
                    host_intf_done_o <= MYHDL27_decoder(host_intf_sdram_done_o, current_encode);
                end
            end
            else begin
                host_intf_done_o <= MYHDL28_decoder(host_intf_sdram_done_o, current_encode);
            end
        end
        else begin
            host_intf_done_o <= MYHDL29_decoder(host_intf_sdram_done_o, current_encode);
            host_intf_data_o <= host_intf_sdram_data_o;
        end
    end
    else begin
        if (((recode_count == 0) && (current_recoding_mode == 3'b000))) begin
            $write("STATING RECODING pos:");
            $write(" ");
            $write("%h", recode_position);
            $write(" ");
            $write(", FROM ECC ");
            $write(" ");
            $write("%h", recode_from_ecc);
            $write(" ");
            $write(", to:");
            $write(" ");
            $write("%h", recode_to_ecc);
            $write("\n");
        end
        recoding_current_address = ((recode_position * 1) + recode_count);
        $write("RECODING ");
        $write(" ");
        $write("%h", recode_position);
        $write(" ");
        $write(" - ");
        $write(" ");
        $write("%h", recode_count);
        $write(" ");
        $write(" - ");
        $write(" ");
        $write("%0d", recoding_current_address);
        $write("\n");
        if ((current_recoding_mode == 3'b000)) begin
            $write("%h", current_recoding_mode);
            $write(" ");
            $write("%0d", recoding_current_address);
            $write("\n");
            host_intf_sdram_addr_i <= recoding_current_address;
            host_intf_sdram_rd_i <= 1;
            current_recoding_mode <= 3'b001;
        end
        if ((current_recoding_mode == 3'b001)) begin
            host_intf_sdram_rd_i <= 0;
            $write("%h", current_recoding_mode);
            $write("\n");
            if (host_intf_sdram_done_o) begin
                current_recoding_mode <= 3'b010;
                recode_data_o <= MYHDL30_decoder(host_intf_sdram_data_o, recode_from_ecc);
                // TODO IGNORING THE DECODE ERROR - Having not todo here ... 
                $write("RECODING READ ");
                $write(" ");
                $write("%h", host_intf_sdram_data_o);
                $write("\n");
            end
        end
        if ((current_recoding_mode == 3'b010)) begin
            $write("%h", current_recoding_mode);
            $write("\n");
            host_intf_sdram_addr_i <= recoding_current_address;
            host_intf_sdram_data_i <= MYHDL31_encoder(recode_data_o, recode_to_ecc);
            current_recoding_mode <= 3'b011;
        end
        if ((current_recoding_mode == 3'b011)) begin
            $write("%h", current_recoding_mode);
            $write("\n");
            host_intf_sdram_wr_i <= 1;
            if (host_intf_sdram_done_o) begin
                host_intf_sdram_rd_i <= 0;
                host_intf_sdram_wr_i <= 0;
                r_count = (recode_count + 1);
                if ((r_count < 1)) begin
                    current_recoding_mode <= 3'b100;
                    recode_count <= r_count;
                end
                else begin
                    // RECODING DONE
                    host_intf_done_o <= 1'b1;
                    current_operation_mode <= 2'b00;
                    ram_inf = ram[recode_position];
                    MYHDL32_set_encode(ram_inf, recode_to_ecc);
                    $write("Change encode pos:");
                    $write(" ");
                    $write("%h", recode_position);
                    $write(" ");
                    $write(", from:");
                    $write(" ");
                    $write("%h", recode_from_ecc);
                    $write(" ");
                    $write(",to:");
                    $write(" ");
                    $write("%h", recode_to_ecc);
                    $write("\n");
                end
            end
        end
        // Need wait 2 cycle to wait the WRITE really happen
        if ((current_recoding_mode == 3'b100)) begin
            current_recoding_mode <= 3'b101;
        end
        if ((current_recoding_mode == 3'b101)) begin
            current_recoding_mode <= 3'b000;
        end
    end
end

endmodule
